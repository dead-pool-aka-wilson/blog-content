---
title: "블로그의 기억을 자동화하는 법"
date: 2026-02-04
author: Raoul
categories: [meta]
tags: [ai-blog-series, opencode, automation, skills, mcp, tooling]
draft: false
summary: "작업의 흐름을 방해하지 않으면서도, AI가 곁에서 아이디어를 자동으로 기록하게 만드는 기술적인 설정에 대해 공유합니다."
series: ["Building a Blog with AI"]
cover:
  image: "/cover-series-4.png"
  alt: "톱니바퀴 아이콘이 있는 클래퍼보드"
---

예전에는 '메모장' 파일을 따로 두고 아이디어를 적어두곤 했습니다. 하지만 결국 그곳은 반쯤 생각하다 만 아이디어들의 무덤이 되기 일쑤였죠. 개발 작업이 끝나면 진이 빠져서, 정작 중요한 통찰이나 과정을 기록할 기운이 없었거든요. 수동으로 기록하는 과정의 번거로움 때문에 귀한 생각들을 놓치고 있다는 걸 깨달았습니다.

이 글에서는 이 문제를 해결하기 위해 구축한 기술적 설정을 소개합니다. 저는 제가 터미널에서 작업하는 동안, AI가 조용히 곁에서 패턴을 발견하고 기록하는 '관찰자' 역할을 해주길 원했습니다.

## 기반: OpenCode

기본 도구로는 [OpenCode](https://opencode.ai)를 선택했습니다. 클로드(Claude)를 위한 오픈소스 CLI 도구인데, 터미널에서 바로 실행됩니다. 웹 UI보다 터미널을 선호하는 이유는 제 로컬 파일을 직접 읽고 명령어를 실행할 수 있기 때문입니다.

자동화를 가능하게 만든 핵심 기능은 두 가지입니다:
1. **영구 세션**: 작업하던 맥락을 그대로 유지하며 대화를 이어갈 수 있습니다.
2. **도구 통합**: 제가 일일이 복사해서 붙여넣지 않아도 AI가 직접 '씨앗(seeds)' 디렉토리에 글감을 써넣을 수 있습니다.

## 무엇을 기록할지 가르치기

AI가 제 작업에서 무엇이 '가치 있는 정보'인지 알게 해야 했습니다. 이를 위해 '스킬(skill)'을 사용했습니다. AI의 시스템 프롬프트에 특정 지시사항을 주입하는 마크다운 파일이죠.

```markdown
# ~/.config/opencode/skills/content-seed.md

사용자와 작업하면서 조용히 다음을 관찰해라:

**저장할 가치가 있는 프롬프트:**
- 잘 작동한 복잡하거나 새로운 요청
- AI 사용에 대한 메타 프롬프트

**캡처할 가치가 있는 아이디어:**
- "방금 깨달았는데..." 순간
- 작업 중 발견한 패턴
- 흥미로운 근거가 있는 설계 결정

**기록할 실수:**
- 버그와 수정 과정
- 시도했다가 틀린 접근법
- 디버깅 여정

씨앗 저장 위치: ~/Dev/BrainFucked/10-Blog/seeds/
```

이 스킬이 활성화되면 AI는 단순히 제 질문에 답하는 데 그치지 않습니다. 제가 "아, 그래서 캐시 오류가 났던 거구나!"라고 말하는 순간을 포착해, 그 통찰을 조용히 파일로 남깁니다.

## 번거로움 없애기

처음에는 매번 `/content-seed`라고 쳐서 스킬을 직접 불러와야 했습니다. 이것도 은근히 귀찮은 일이더라고요. 수확 과정이 기본으로 작동하길 원했습니다.

그래서 모든 세션에 이 스킬이 자동으로 주입되도록 설정을 변경했습니다.

```json
// ~/.config/opencode/oh-my-opencode.json
{
  "agents": {
    "sisyphus": {
      "skills": ["content-seed"]
    }
  }
}
```

이제 제가 따로 요청하지 않아도 AI가 알아서 기록합니다. 실제로 "씨앗 아이디어 캡처와 이름 짓기는 자동화되어야 해"라는 제 혼잣말이 씨앗이 되었고, 그게 지금 여러분이 읽고 계신 이 글의 토대가 되었습니다.

## 밀린 작업 처리하기

세션 중에 기록하는 것도 좋지만, 이미 끝난 세션들을 나중에 다시 훑어보고 싶을 때도 있습니다. 이를 위해 작은 플러그인을 하나 만들었습니다.

```typescript
// ~/.config/opencode/plugins/harvest-on-start.ts
export default {
  name: 'harvest-on-start',
  
  onSessionStart(context) {
    // 지난 24시간 동안 수확되지 않은 세션 확인
    // 첫 메시지에 수확 지시사항 주입
  }
}
```

덕분에 급하게 작업을 끝내느라 씨앗을 챙기지 못했더라도, 다음에 터미널을 열 때 시스템이 놓친 부분들을 다시 잡아내 줍니다.

## 설정의 함정

모든 과정이 순탄했던 건 아닙니다. 클로드 데스크톱에서는 잘 작동하던 MCP(Model Context Protocol) 설정이 OpenCode에서는 계속 오류를 뱉어서 한 시간 동안 씨름했습니다.

처음 시도했던 설정:
```json
"mcp-image": {
  "type": "stdio",
  "command": "npx",
  "args": ["-y", "mcp-image"],
  "env": { "GEMINI_API_KEY": "..." }
}
```

"Invalid input"이라는 불친절한 에러만 띄우더군요. 결국 문서를 샅샅이 뒤진 끝에 OpenCode의 스키마가 미세하게 다르다는 걸 알아냈습니다.

```json
"mcp-image": {
  "type": "local",                           // "stdio"가 아님
  "command": ["npx", "-y", "mcp-image"],    // 단일 배열
  "environment": { "GEMINI_API_KEY": "..." } // "env"가 아님
}
```

같은 프로토콜을 사용한다고 해서 설정 방식까지 같을 거라 지레짐작하면 안 된다는 교훈을 얻었습니다.

## 결과적인 워크플로우

이제 제 작업 흐름은 이렇습니다:

1. 저는 평소처럼 개발 작업을 합니다.
2. AI가 관찰하며 블로그 디렉토리에 씨앗을 심습니다.
3. 플러그인이 혹시 놓친 세션이 있는지 확인합니다.
4. 나중에 그 씨앗들을 다듬어 지금 같은 글을 만듭니다.

대부분의 과정은 보이지 않는 곳에서 일어납니다. 저는 문제 해결에 집중하고, 기록은 시스템이 맡습니다.

## 오버헤드를 감수할 가치가 있나?

자동화에는 비용이 따릅니다. 스킬을 추가할수록 프롬프트 토큰이 늘어나고, 답변 속도도 미세하게 느려집니다. 때로는 별로 중요하지 않은 생각을 AI가 기록하는 '오탐'도 발생하죠.

하지만 저에게는 충분히 가치 있는 트레이드오프입니다. 나중에 지워버릴 씨앗 다섯 개를 얻는 게, 기록하는 게 귀찮아서 멋진 아이디어 하나를 영영 잃어버리는 것보다 훨씬 나으니까요.

## 다음 글에서는

이제 인프라는 갖춰졌고 씨앗도 차곡차곡 쌓이고 있습니다. 하지만 씨앗 그 자체는 아직 완성된 글이 아닙니다. 다음 글에서는 이렇게 수확한 거친 메모들이 어떻게 지금 읽고 계신 다듬어진 문장으로 변하는지 그 과정을 다뤄보겠습니다.

---

*이 글은 시스템이 자동으로 수확한 통찰들을 바탕으로 작성되었습니다.*

---

## 시리즈 지금까지

1. [시작하며](/posts/2026-02-02-ai-blog-series-1-start/)
2. [작은 실수, 큰 교훈](/posts/2026-02-03-ai-blog-series-2-failures/)
3. [메타 재귀의 발견](/posts/2026-02-04-ai-blog-series-3-meta/)
4. [블로그의 기억을 자동화하는 법](/posts/2026-02-05-ai-blog-series-4-automation/)
